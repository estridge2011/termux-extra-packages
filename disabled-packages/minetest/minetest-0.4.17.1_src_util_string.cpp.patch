diff -uNr minetest-0.4.17.1/src/util/string.cpp minetest-0.4.17.1.mod/src/util/string.cpp
--- minetest-0.4.17.1/src/util/string.cpp	2018-06-10 18:18:11.000000000 +0300
+++ minetest-0.4.17.1.mod/src/util/string.cpp	2018-09-04 17:30:51.638067755 +0300
@@ -103,13 +103,6 @@
 	return out;
 }
 
-#ifdef __ANDROID__
-// TODO: this is an ugly fix for wide_to_utf8 somehow not working on android
-std::string wide_to_utf8(const std::wstring &input)
-{
-	return wide_to_narrow(input);
-}
-#else
 std::string wide_to_utf8(const std::wstring &input)
 {
 	size_t inbuf_size = (input.length() + 1) * sizeof(wchar_t);
@@ -136,7 +129,6 @@
 	return out;
 }
 
-#endif
 #else // _WIN32
 
 std::wstring utf8_to_wide(const std::string &input)
@@ -201,63 +193,6 @@
 }
 
 
-#ifdef __ANDROID__
-
-const wchar_t* wide_chars =
-	L" !\"#$%&'()*+,-./0123456789:;<=>?@"
-	L"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
-	L"abcdefghijklmnopqrstuvwxyz{|}~";
-
-int wctomb(char *s, wchar_t wc)
-{
-	for (unsigned int j = 0; j < (sizeof(wide_chars)/sizeof(wchar_t));j++) {
-		if (wc == wide_chars[j]) {
-			*s = (char) (j+32);
-			return 1;
-		}
-		else if (wc == L'\n') {
-			*s = '\n';
-			return 1;
-		}
-	}
-	return -1;
-}
-
-int mbtowc(wchar_t *pwc, const char *s, size_t n)
-{
-	std::wstring intermediate = narrow_to_wide(s);
-
-	if (intermediate.length() > 0) {
-		*pwc = intermediate[0];
-		return 1;
-	}
-	else {
-		return -1;
-	}
-}
-
-std::wstring narrow_to_wide(const std::string &mbs) {
-	size_t wcl = mbs.size();
-
-	std::wstring retval = L"";
-
-	for (unsigned int i = 0; i < wcl; i++) {
-		if (((unsigned char) mbs[i] >31) &&
-		 ((unsigned char) mbs[i] < 127)) {
-
-			retval += wide_chars[(unsigned char) mbs[i] -32];
-		}
-		//handle newline
-		else if (mbs[i] == '\n') {
-			retval += L'\n';
-		}
-	}
-
-	return retval;
-}
-
-#else // not Android
-
 std::wstring narrow_to_wide(const std::string &mbs)
 {
 	size_t wcl = mbs.size();
@@ -269,38 +204,6 @@
 	return *wcs;
 }
 
-#endif
-
-#ifdef __ANDROID__
-
-std::string wide_to_narrow(const std::wstring &wcs) {
-	size_t mbl = wcs.size()*4;
-
-	std::string retval = "";
-	for (unsigned int i = 0; i < wcs.size(); i++) {
-		wchar_t char1 = (wchar_t) wcs[i];
-
-		if (char1 == L'\n') {
-			retval += '\n';
-			continue;
-		}
-
-		for (unsigned int j = 0; j < wcslen(wide_chars);j++) {
-			wchar_t char2 = (wchar_t) wide_chars[j];
-
-			if (char1 == char2) {
-				char toadd = (j+32);
-				retval += toadd;
-				break;
-			}
-		}
-	}
-
-	return retval;
-}
-
-#else // not Android
-
 std::string wide_to_narrow(const std::wstring &wcs)
 {
 	size_t mbl = wcs.size() * 4;
@@ -313,8 +216,6 @@
 	return *mbs;
 }
 
-#endif
-
 std::string urlencode(const std::string &str)
 {
 	// Encodes non-unreserved URI characters by a percent sign
